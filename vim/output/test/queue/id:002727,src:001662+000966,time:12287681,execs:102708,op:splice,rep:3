" Test the :disassemble command, and compilation as a side effect

source check.vim
import './vim9.vim' as v9

func s:NotCompiled()
  echo "not"
endfunc

let s:scriptvar = 4
let g:globalvar = 'g'
let b:buffervar = 'b'
let w:windowvar = 'w'
let t:tabpagevar = 't'

def s:ScriptFuncLoad(arg: string)
  var local = 1
  buffers
  echo
  echo arg
  echo local
  echo &lines
  echo v:version
  echo s:scriptvar
  echo g:globalvar
  echo get(g:, "global")
  echo g:auto#var
  echo b:buffervar
  echo get(b:, "buffer")
  echo w:windowvar
  echo get(w:, "window")
  echo t:tabpagevar
  echo get(t:, "tab")
  echo &tabstop
  echo $ENVVAR
  echo @z
enddef

def Test_disassemble_load()
  assert_fails('disass NoFunc', 'E1061:')
  assert_fails('disass NotCompiled', 'E1091:')
  assert_fails('disass', 'E471:')
  assert_fails('disass [', 'E475:')
  assert_fails('disass 234', 'E129:')
  assert_fails('disass <XX>foo', 'E129:')
  assert_fails('disass Test_disassemble_load burp', 'E488:')
  assert_fails('disass debug debug Test_disassemble_load', 'E488:')
  assert_fails('disass profile profile Test_disassemble_load', 'E488:')

  var res = execute('disass s:ScriptFuncLoad')
  assert_match('<SNR>\d*_ScriptFuncLoad.*' ..
        'buffers\_s*' ..
        '\d\+ EXEC \+buffers\_s*' ..
        'echo\_s*' ..
        'echo arg\_s*' ..
        '\d\+ LOAD arg\[-1\]\_s*' ..
        '\d\+ ECHO 1\_s*' ..
        'echo local\_s*' ..
        '\d\+ LOAD $0\_s*' ..
        '\d\+ ECHO 1\_s*' ..
        'echo &lines\_s*' ..
        '\d\+ LOADOPT &lines\_s*' ..
        '\d\+ ECHO 1\_s*' ..
        'echo v:version\_s*' ..
        '\d\+ LOADV v:version\_s*' ..
        '\d\+ ECHO 1\_s*' ..
        'echo s:scriptvar\_s*' ..
        '\d\+ LOADS s:scriptvar from .*test_vim9_disassemble.vim\_s*' ..
        '\d\+ ECHO 1\_s*' ..
        'echo g:globalvar\_s*' ..
        '\d\+ LOADG g:globalvar\_s*' ..
        '\d\+ ECHO 1\_s*' ..
        'echo get(g:, "global")\_s*' ..
        '\d\+ LOAD g:\_s*' ..
        '\d\+ PUSHS "global"\_s*' ..
        '\d\+ BCALL get(argc 2)\_s*' ..
        '\d\+ ECHO 1\_s*' ..
        'echo g:auto#var\_s*' ..
        '\d\+ LOADAUTO g:auto#var\_s*' ..
        '\d\+ ECHO 1\_s*' ..
        'echo b:buffervar\_s*' ..
        '\d\+ LOADB b:buffervar\_s*' ..
        '\d\+ ECHO 1\_s*' ..
        'echo get(b:, "buffer")\_s*' ..
        '\d\+ LOAD b:\_s*' ..
        '\d\+ PUSHS "buffer"\_s*' ..
        '\d\+ BCALL get(argc 2).*' ..
        ' LOADW w:windowvar.*' ..
        'echo get(w:, "window")\_s*' ..
        '\d\+ LOAD w:\_s*' ..
        '\d\+ PUSHS "window"\_s*' ..
        '\d\+ BCALL get(argc 2).*' ..
        ' LOADT t:tabpagevar.*' ..
        'echo get(t:, "tab")\_s*' ..
        '\d\+ LOAD t:\_s*' ..
        '\d\+ PUSHS "tab"\_s*' ..
        '\d\+ BCALL get(argc 2).*' ..
        ' LOADENV $ENVVAR.*' ..
        ' LOADRE    'var localstr = ''anddef

def s:EditExpand()
  var filename = "file"
  var filenr = 123
  edit the`=filename``=filenr`.txt
enddef

def Test_disassemble_exec_expr()
  var res = execute('disass s:EditExpand')
  assert_match('<SNR>\d*_EditExpand\_s*' ..
        ' var filename = "file"\_s*' ..
        '\d PUSHS "file"\_s*' ..
        '\d STORE $0\_s*' ..
        ' var filenr = 123\_s*' ..
        '\d STORE 123 in $1\_s*' ..
        ' edit the`=filename``=filenr`.txt\_s*' ..
        '\d PUSHS "edit the"\_s*' ..
        '\d LOAD $0\_s*' ..
        '\d LOAD $1\_s*' ..
        '\d 2STRING stack\[-1\]\_s*' ..
        '\d\+ PUSHS ".txt"\_s*' ..
        '\d\+ EXECCONCAT 4\_s*' ..
        '\d\+ RETURN void',
        res)
enddef

if has('python3')
  def s:PyHeredoc()
    python3 << EOF
      print('hello')
EOF
  enddef

  def Test_disassemble_python_heredoc()
    var res = execute('disass s:PyHeredoc')
    assert_match('<SNR>\d*_PyHeredoc.*' ..
          "    python3 << EOF^@      print('hello')^@EOF\\_s*" ..
          '\d EXEC_SPLIT     python3 << EOF^@      print(''hello'')^@EOF\_s*' ..
          '\d RETURN void',
          res)
  enddef
endif

def s:Substitute()
  var expr = "abc"
  :%s/a/\=expr/&g#c
enddef

def Test_disassemble_substitute()
  var res = execute('disass s:Substitute')
  assert_match('<SNR>\d*_Substitute.*' ..
        ' var expr = "abc"\_s*' ..
        '\d PUSHS "abc"\_s*' ..
        '\d STORE $0\_s*' ..
        ' :%s/a/\\=expr/&g#c\_s*' ..
        '\d SUBSTITUTE   :%s/a/\\=expr/&g#c\_s*' ..
        '    0 LOAD $0\_s*' ..
        '    -------------\_s*' ..
        '\d RETURN void',
        res)
enddef


def s:SearchPair()
  var col = 8
  searchpair("{", "", "}", "", "col('.') > col")
enddef

def Test_disassemble_seachpair()
  var res = execute('disass s:SearchPair')
  assert_match('<SNR>\d*_SearchPair.*' ..
        ' var col = 8\_s*' ..
        '\d STORE 8 in $0\_s*' ..
        ' searchpair("{", "", "}", "", "col(''.'') > col")\_s*' ..
        '\d PUSHS "{"\_s*' ..
        '\d PUSHS ""\_s*' ..
        '\d PUSHS "}"\_s*' ..
        '\d PUSHS ""\_s*' ..
        '\d INSTR\_s*' ..
        '  0 PUSHS "."\_s*' ..
        '  1 BCALL col(argc 1)\_s*' ..
        '  2 LOAD $0\_s*' ..
        '  3 COMPARENR >\_s*' ..
        ' -------------\_s*' ..
        '\d BCALL searchpair(argc 5)\_s*' ..
        '\d DROP\_s*' ..
        '\d RETURN void',
        res)
enddef


def s:SubstituteExpr()
    substitute('a', 'b', '\=123', 'g')
enddef

def Test_disassemble_substitute_expr()
  var res = execute('disass s:SubstituteExpr')
  assert_match('<SNR>\d*_SubstituteExpr.*' ..
        'substitute(''a'', ''b'', ''\\=123'', ''g'')\_s*' ..
        '\d PUSHS "a"\_s*' ..
        '\d PUSHS "b"\_s*' ..
        '\d INSTR\_s*' ..
        '  0 PUSHNR 123\_s*' ..
        ' -------------\_s*' ..
        '\d PUSHS "g"\_s*' ..
        '\d BCALL substitute(argc 4)\_s*' ..
        '\d DROP\_s*' ..
        '\d RETURN void',
        res)
enddef

def s:RedirVar()
  var result: string
  redir =>> result
    echo "text"
  redir END
enddef

def Test_disassemble_redir_var()
  var res = execute('disass s:RedirVar')
  assert_match('<SNR>\d*_RedirVar.*' ..
        ' var result: string\_s*' ..
        '\d PUSHS "\[NULL\]"\_s*' ..
        '\d STORE $0\_s*' ..
        ' redir =>> result\_s*' ..
        '\d REDIR\_s*' ..
        ' echo "text"\_s*' ..
        '\d PUSHS "text"\_s*' ..
        '\d ECHO 1\_s*' ..
        ' redir END\_s*' ..
        '\d LOAD $0\_s*' ..
        '\d REDIR END\_s*' ..
        '\d CONCAT size 2\_s*' ..
        '\d STORE $0\_s*' ..
        '\d RETURN void',
        res)
enddef

def s:Cexpr()
  var errors = "list of errors"
  cexpr errors
enddef

def Test_disassemble_cexpr()
  var res = execute('disass s:Cexpr')
  assert_match('<SNR>\d*_Cexpr.*' ..
        ' var errors = "list of errors"\_s*' ..
        '\d PUSHS "list of errors"\_s*' ..
        '\d STORE $0\_s*' ..
        ' cexpr errors\_s*' ..
        '\d CEXPR pre cexpr\_s*' ..
        '\d LOAD $0\_s*' ..
        '\d CEXPR core cexpr "cexpr errors"\_s*' ..
        '\d RETURN void',
        res)
enddef

def s:YankRange()
  norm! m[jjm]
  :'[,']yank
enddef

def Test_disassemble_yank_range()
  var res = execute('disass s:YankRange')
  assert_match('<SNR>\d*_YankRange.*' ..
        ' norm! m\[jjm\]\_s*' ..
        '\d EXEC   norm! m\[jjm\]\_s*' ..
        '  :''\[,''\]yank\_s*' ..
        '\d EXEC   :''\[,''\]yank\_s*' ..
        '\d RETURN void',
        res)
enddef

def s:PutExpr()
  :3put ="text"
enddef

def Test_disassemble_put_expr()
  var res = execute('disass s:PutExpr')
  assert_match('<SNR>\d*_PutExpr.*' ..
        ' :3put ="text"\_s*' ..
        '\d PUSHS "text"\_s*' ..
        '\d PUT = 3\_s*' ..
        '\d RETURN void',
        res)
enddef

def s:PutRange()
  :$-2put a
  :$-3put! b
enddef

def Test_disassemble_put_range()
  var res = execute('disass s:PutRange')
  assert_match('<SNR>\d*_PutRange.*' ..
        ' :$-2put a\_s*' ..
        '\d RANGE $-2\_s*' ..
        '\d PUT a range\_s*' ..

        ' :$-3put! b\_s*' ..
        '\d RANGE $-3\_s*' ..
        '\d PUT b above range\_s*' ..
        '\d RETURN void',
        res)
enddef

def s:ScriptFuncPush()
  var localbool = true
  var localspec = v:none
  var localblob = 0z1234
  var localfloat = 1.234
enddef

def Test_disassemble_push()
  mkdir('Xdisdir/autoload', 'pR')
  var save_rtp = &rtp
  exe 'set rtp^=' .. getcwd() .. '/Xdisdir'

  var lines =<< trim END
      vim9script
  END
  writefile(lines, 'Xdisdir/autoload/autoscript.vim')

  lines =<< trim END
      vim9script
      import autoload 'autoscript.vim'

      def AutoloadFunc()
        &operatorfunc = autoscript.Opfunc
      enddef

      var res = execute('disass AutoloadFunc')
      assert_match('<SNR>\d*_AutoloadFunc.*' ..
            '&operatorfunc = autoscript.Opfunc\_s*' ..
            '0 AUTOLOAD autoscript#Opfunc\_s*' ..
            '1 STOREFUNCOPT &operatorfunc\_s*' ..
            '2 RETURN void',
            res)
  END
  v9.CheckScriptSuccess(lines)

  &rtp = save_rtp
enddef

def Test_disassemble_import_autoload()
  writefile(['vim9script'], 'XimportAL.vim', 'D')

  var lines =<< trim END
      vim9script
      import autoload './XimportAL.vim'

      def AutoloadFunc()
        echo XimportAL.SomeFunc()
        echo XimportAL.someVar
        XimportAL.someVar = "yes"
      enddef

      var res = execute('disass AutoloadFunc')
      assert_match('<SNR>\d*_AutoloadFunc.*' ..
            'echo XimportAL.SomeFunc()\_s*' ..
            '\d SOURCE .*/testdir/XimportAL.vim\_s*' ..
            '\d PUSHFUNC "<80><fd>R\d\+_SomeFunc"\_s*' ..
            '\d PCALL top (argc 0)\_s*' ..
            '\d PCALL end\_s*' ..
            '\d ECHO 1\_s*' ..

            'echo XimportAL.someVar\_s*' ..
            '\d SOURCE .*/testdir/XimportAL.vim\_s*' ..
            '\d LOADEXPORT s:someVar from .*/testdir/XimportAL.vim\_s*' ..
            '\d ECHO 1\_s*' ..

            'XimportAL.someVar = "yes"\_s*' ..
            '\d\+ PUSHS "yes"\_s*' ..
            '\d\+ SOURCE .*/testdir/XimportAL.vim\_s*' ..
            '\d\+ STOREEXPORT someVar in .*/testdir/XimportAL.vim\_s*' ..

            '\d\+ RETURN void',
            res)
  END
  v9.CheckScriptSuccess(lines)
enddef

def s:ScriptFuncStore()
  var localnr = 1
  localnr = 2
  var localstr = 'abc'
  localstr = 'xyz'
  v:char = 'abc'
  s:scriptvar = 'sv'
  g:globalvar = 'gv'
  g:auto#var = 'av'
  b:b»ffervar = 'bv'
  w:windowvar = 'wv'
  t:tabpagevar = 'tv'
  &tabstop = 8
  &opfunc = (t) => len(t)
  $ENVVAR = 'ev'
  @z = 'rv'
enddef

def Test_disassemble_store()
  var res = execute('disass s:ScriptFuncStore')
  assert_match('<SNR>\d*_ScriptFuncStore.*' ..
        'var localnr = 1.*' ..
        'localnr = 2.*' ..
        ' STORE 2 in $0.*' ..
    G @z.*',
        res)
ebc''.*' ..
        'localstr = ''xyz''.*' ..
        ' STORE $1.*' ..
        'v:char = ''abc''.*' ..
        'STOREV v:char.*' ..
        's:scriptvar = ''sv''.*' ..
        ' STORES s:scriptvar in .*test_vim9_disassemble.vim.*' ..
        'g:globalvar = ''gv''.*' ..
        ' STOREG g:globalvar.*' ..
        'g:auto#var = ''av''.*' ..
        ' STOREAUTO g:auto#var.*' ..
        'b:buffervar = ''bv''.*' ..
        ' STOREB b:buffervar.*' ..
        'w:windowvar = ''wv''.*' ..
        ' STOREW w:windowvar.*' ..
        't:tabpagevar = ''tv''.*' ..
        ' STORET t:tabpagevar.*' ..
        '&tabstop = 8\_s*' ..
        '\d\+ PUSHNR 8\_s*' ..
        '\d\+ STOREOPT &tabstop\_s*' ..
        '&opfunc = (t) => len(t)\_s*' ..
        '\d\+ FUNCREF <lambda>\d\+\_s*' ..
        '\d\+ STOREFUNCOPT &opfunc\_s*' ..
        '$ENVVAR = ''ev''\_s*' ..
        '\d\+ PUSHS "ev"\_s*' ..
        '\d\+ STOREENV $ENVVAR\_s*' ..
        '@z = ''rv''.*' ..
        '\d\+ STOREREG @z.*',
        res)
enddef

def s:ScriptFuncStoreMember()
  var locallist: list<number> = []
  locallist[0] = 123
  var localdict: dict<number> = {}
  localdict["a"] = 456
  var localblob: blob = 0z1122
  localblob[1] = 33
enddef

def Test_disassemble_store_member()
  var res = execute('disass s:ScriptFuncStoreMember')
  assert_match('<SNR>\d*_ScriptFuncStoreMember\_s*' ..
        'var locallist: list<number> = []\_s*' ..
        '\d NEWLIST size 0\_s*' ..
        '\d SETTYPE list<number>\_s*' ..
        '\d STORE $0\_s*' ..
        'locallist\[0\] = 123\_s*' ..
        '\d PUSHNR 123\_s*' ..
        '\d PUSHNR 0\_s*' ..
        '\d LOAD $0\_s*' ..
        '\d STOREINDEX list\_s*' ..
        'var localdict: dict<number> = {}\_s*' ..
        '\d NEWDICT size 0\_s*' ..
        '\d SETTYPE dict<number>\_s*' ..
        '\d STORE $1\_s*' ..
        'localdict\["a"\] = 456\_s*' ..
        '\d\+ PUSHNR 456\_s*' ..
        '\d\+ PUSHS "a"\_s*' ..
        '\d\+ LOAD $1\_s*' ..
        '\d\+ STOREINDEX dict\_s*' ..
        'var localblob: blob = 0z1122\_s*' ..
        '\d\+ PUSHBLOB 0z1122\_s*' ..
        '\d\+ STORE $2\_s*' ..
        'localblob\[1\] = 33\_s*' ..
        '\d\+ PUSHNR 33\_s*' ..
        '\d\+ PUSHNR 1\_s*' ..
        '\d\+ LOAD $2\_s*' ..
        '\d\+ STOREINDEX blob\_s*' ..
        '\d\+ RETURN void',
        res)
enddef

if has('job')
  def s:StoreNull()
    var ss = null_string
    var bb = null_blob
    var dd = null_dict
    var ll = null_list
    var Ff = null_function
    var Pp = null_partial
    var jj = null_job
    var cc = null_channel
    var oo = null_object
    var nc = null_class
  enddef

  def Test_disassemble_assign_null()
    var res = execute('disass s:StoreNull')
    assert_match('<SNR>\d*_StoreNull\_s*' ..
          'var ss = null_string\_s*' ..
          '\d\+ PUSHS "\[NULL\]"\_s*' ..
          '\d\+ STORE $\d\_s*' ..

          'var bb = null_blob\_s*' ..
          '\d\+ PUSHBLOB 0z\_s*' ..
          '\d\+ STORE $\d\_s*' ..

          'var dd = null_dict\_s*' ..
          '\d\+ NEWDICT size -1\_s*' ..
          '\d\+ STORE $\d\_s*' ..

          'var ll = null_list\_s*' ..
          '\d\+ NEWLIST size -1\_s*' ..
          '\d\+ STORE $\d\_s*' ..

          'var Ff = null_function\_s*' ..
          '\d\+ PUSHFUNC "\[none\]"\_s*' ..
          '\d\+ STORE $\d\_s*' ..

          'var Pp = null_partial\_s*' ..
          '\d\+ NEWPARTIAL\_s*' ..
          '\d\+ STORE $\d\_s*' ..

          'var jj = null_job\_s*' ..
          '\d\+ PUSHJOB "no process"\_s*' ..
          '\d\+ STORE $\d\_s*' ..

          'var cc = null_channel\_s*' ..
          '\d\+ PUSHCHANNEL 0\_s*' ..
          '\d\+ STORE $\d\_s*' ..

          'var oo = null_object\_s*' ..
          '\d\+ PUSHOBJ null\_s*' ..
          '\d\+ STORE $\d\_s*' ..

          'var nc = null_class\_s*' ..
          '\d\+ PUSHCLASS null\_s*' ..
          '\d\+ STORE $\d\_s*' ..

          '\d\+ RETURN void',
          res)
  enddef
endif

def s:ScriptFuncStoreIndex()
  var d = {dd: {}}
  d.dd[0] = 0
enddef

def Test_disassemble_store_index()
  var res = execute('disass s:ScriptFuncStoreIndex')
  assert_match('<SNR>\d*_ScriptFuncStoreIndex\_s*' ..
        'var d = {dd: {}}\_s*' ..
        '\d PUSHS "dd"\_s*' ..
        '\d NEWDICT size 0\_s*' ..
        '\d NEWDICT size 1\_s*' ..
        '\d SETTYPE dict<dict<any>>\_s*' ..
        '\d STORE $0\_s*' ..
        'd.dd\[0\] = 0\_s*' ..
        '\d PUSHNR 0\_s*' ..
        '\d PUSHNR 0\_s*' ..
        '\d LOAD $0\_s*' ..
        '\d MEMBER dd\_s*' ..
        '\d\+ USEDICT\_s*' ..
        '\d\+ STOREINDEX any\_s*' ..
        '\d\+ RETURN void',
        res)
enddef

def s:ListAssign()
  var x: string
  var y: string
  var l: list<any>
  [x, y; l] = g:stringlist
enddef

def Test_disassemble_list_assign()
  var res = execute('disass s:ListAssign')
  assert_match('<SNR>\d*_ListAssign\_s*' ..
        'var x: string\_s*' ..
        '\d PUSHS "\[NULL\]"\_s*' ..
        '\d STORE $0\_s*' ..
        'var y: string\_s*' ..
        '\d PUSHS "\[NULL\]"\_s*' ..
        '\d STORE $1\_s*' ..
        'var l: list<any>\_s*' ..
        '\d NEWLIST size 0\_s*' ..
        '\d STORE $2\_s*' ..
        '\[x, y; l\] = g:stringlist\_s*' ..
        '\d LOADG g:stringlist\_s*' ..
        '\d CHECKTYPE list<any> stack\[-1\]\_s*' ..
        '\d CHECKLEN >= 2\_s*' ..
        '\d\+ ITEM 0\_s*' ..
        '\d\+ CHECKTYPE string stack\[-1\] var 1\_s*' ..
        '\d\+ STORE $0\_s*' ..
        '\d\+ ITEM 1\_s*' ..
        '\d\+ CHECKTYPE string stack\[-1\] var 2\_s*' ..
        '\d\+ STORE $1\_s*' ..
        '\d\+ SLICE 2\_s*' ..
        '\d\+ STORE $2\_s*' ..
        '\d\+ RETURN void',
        res)
enddef

def s:ListAssignWithOp()
  var a = 2
  var b = 3
  [a, b] += [4, 5]
enddef

def Test_disassemble_list_assign_with_op()
  var res = execute('disass s:ListAssignWithOp')
  assert_match('<SNR>\d*_ListAssignWithOp\_s*' ..
        'var a = 2\_s*' ..
        '\d STORE 2 in $0\_s*' ..
        'var b = 3\_s*' ..
        '\d STORE 3 in $1\_s*' ..
        '\[a, b\] += \[4, 5\]\_s*' ..
        '\d\+ PUSHNR 4\_s*' ..
        '\d\+ PUSHNR 5\_s*' ..
        '\d\+ NEWLIST size 2\_s*' ..
        '\d\+ LOAD $0\_s*' ..
        '\d\+ ITEM 0 with op\_s*' ..
        '\d\+ OPNR +\_s*' ..
        '\d\+ STORE $0\_s*' ..
        '\d\+ LOAD $1\_s*' ..
        '\d\+ ITEM 1 with op\_s*' ..
        '\d\+ OPNR +\_s*' ..
        '\d\+ STORE $1\_s*' ..
        '\d\+ DROP\_s*' ..
        '\d\+ RETURN void',
        res)
enddef

def s:ListAdd()
  var l: list<number> = []
  add(l, 123)
  add(l, g:aNumber)
enddef

def Test_disassemble_list_add()
  var res = execute('disass s:ListAdd')
  assert_match('<SNR>\d*_ListAdd\_s*' ..
        'var l: list<number> = []\_s*' ..
        '\d NEWLIST size 0\_s*' ..
        '\d SETTYPE list<number>\_s*' ..
        '\d STORE $0\_s*' ..
        'add(l, 123)\_s*' ..
        '\d LOAD $0\_s*' ..
        '\d PUSHNR 123\_s*' ..
        '\d LISTAPPEND\_s*' ..
        '\d DROP\_s*' ..
        'add(l, g:aNumber)\_s*' ..
        '\d LOAD $0\_s*' ..
        '\d\+ LOADG g:aNumber\_s*' ..
        '\d\+ CHECKTYPE number stack\[-1\]\_s*' ..
        '\d\+ LISTAPPEND\_s*' ..
        '\d\+ DROP\_s*' ..
        '\d\+ RETURN void',
        res)
enddef

def s:BlobAdd()
  var b: blob = 0z
  add(b, 123)
  add(b, g:aNumber)
enddef

def Test_disassemble_blob_add()
  var res = execute('disass s:BlobAdd')
  assert_match('<SNR>\d*_BlobAdd\_s*' ..
        'var b: blob = 0z\_s*' ..
        '\d PUSHBLOB 0z\_s*' ..
        '\d STORE $0\_s*' ..
        'add(b, 123)\_s*' ..
        '\d LOAD $0\_s*' ..
        '\d PUSHNR 123\_s*' ..
        '\d BLOBAPPEND\_s*' ..
        '\d DROP\_s*' ..
        'add(b, g:aNumber)\_s*' ..
        '\d LOAD $0\_s*' ..
        '\d\+ LOADG g:aNumber\_s*' ..
        '\d\+ CHECKTYPE number stack\[-1\]\_s*' ..
        '\d\+ BLOBAPPENDvim9script

# Vim syntax file
# Language: ConTeXt
# Automatically generated by mtx-interface (2023-12-26 16:40)

syn keyword texAleph Alephminorversion Alephrevision Alephversion contained
syn keyword texEtex botmarks clubpenalties currentgrouplevel currentgrouptype currentifbranch contained
syn keyword texEtex currentiflevel currentiftype currentstacksize detokenize dimexpr contained
syn keyword texEtex displaywidowpenalties everyeof firstmarks fontchardp fontcharht contained
syn keyword texEtex fontcharic fontcharwd glueexpr glueshrink glueshrinkorder contained
syn keyword texEtex gluestretch gluestretchorder gluetomu ifcsname ifdefined contained
syn keyword texEtex iffontchar interactionmode interlinepenalties lastlinefit lastnodetype contained
syn keyword texEtex marks muexpr mutoglue numexpr pagediscards contained
syn keyword texEtex parshapedimen parshapeindent parshapelength predisplaydirection protected contained
syn keyword texEtex savinghyphcodes savingvdiscards scantokens showgroups showifs contained
syn keyword texEtex showtokens splitbotmarks splitd_scards splitfirstmarks topmarks contained
syn keyword texEtex tracingassigns tracinggroups tracingifs tracingnesting unexpanded contained
syn keyword texEtex unless widowpenalties contained
syn keyword texLuatex Uabove Uabovewithdelims Uatop Uatopwithdelims Uchar contained
syn keyword texLuatex Udelcode Udelimited Udelimiter Udelimiterover Udelimiterunder contained
syn keyword texLuatex Uhextensible Uleft Umathaccent Umathaccentbasedepth Umathaccentbaseheight contained
syn keyword texLuatex Umathaccentbottomovershoot Umathaccentbottomshiftdown Umathaccentextendmargin Umathaccentsuperscriptdrop Umathaccentsuperscriptpercent contained
syn keyword texLuatex Umathaccenttopovershoot Umathaccenttopshiftup Umathaccentvariant Umathadapttoleft Umathadapttoright contained
syn keyword texLuatex Umathaxis Umathbottomaccentvariant Umathchar Umathcharclass Umathchardef contained
syn keyword texLuatex Umathcharfam Umathcharslot Umathclass Umathcode Umathconnectoroverlapmin contained
syn keyword texLuatex Umathdegreevariant Umathdelimiterextendmargin Umathdelimiterovervariant Umathdelimiterpercent Umathdelimitershortfall contained
syn keyword texLuatex Umathdelimiterundervariant Umathdenominatorvariant Umathdict Umathdictdef Umathdiscretionary contained
syn keyword texLuatex Umathextrasubpreshift Umathextrasubprespace Umathextrasubshift Umathextrasubspace Umathextrasuppreshift contained
syn keyword texLuatex Umathextrasupprespace Umathextrasupshift Umathextrasupspace Umathflattenedaccentbasedepth Umathflattenedaccentbaseheight contained
syn keyword texLuatex Umathflattenedaccentbottomshiftdown Umathflattenedaccenttopshiftup Umathfractiondelsize Umathfractiondenomdown Umathfractiondenomvgap contained
syn keyword texLuatex Umathfractionnumup Umathfractionnumvgap Umathfractionrule Umathfractionvariant Umathhextensiblevariant contained
syn keyword texLuatex Umathlimitabovebgap Umathlimitabovekern Umathlimitabovevgap Umathlimitbelowbgap Umathlimitbelowkern contained
syn keyword texLuatex Umathlimitbelowvgap Umathlimits Umathnoaxis Umathnolimits Umathnolimitsubfactor contained
syn keyword texLuatex Umathnolimitsupfactor Umathnumeratorvariant Umathopenupdepth Umathopenupheight Umathoperatorsize contained
syn keyword texLuatex Umathoverbarkern Umathoverbarrule Umathoverbarvgap Umathoverdelimiterbgap Umathoverdelimitervariant contained
syn keyword texLuatex Umathoverdelimitervgap Umathoverlayaccentvariant Umathoverlinevariant Umathphantom Umathpresubshiftdistance contained
syn keyword texLuatex Umathpresupshiftdistance Umathprimeraise Umathprimeraisecomposed Umathprimeshiftdrop Umathprimeshiftup contained
syn keyword texLuatex Umathprimespaceafter Umathprimevariant Umathprimewidth Umathquad Umathradicaldegreeafter contained
syn keyword texLuatex Umathradicaldegreebefore Umathradicaldegreeraise Umathradicalextensibleafter Umathradicalextensiblebefore Umathradicalkern contained
syn keyword texLuatex Umathradicalrule Umathradicalvariant Umathradicalvgap Umathruledepth Umathruleheight contained
syn keyword texLuatex Umathskeweddelimitertolerance Umathskewedfractionhgap Umathskewedfractionvgap Umathsource Umathspaceafterscript contained
syn keyword texLuatex Umathspacebeforescript Umathstackdenomdown Umathstacknumup Umathstackvariant Umathstackvgap contained
syn keyword texLuatex Umathsubscriptvariant Umathsubshiftdistance Umathsubshiftdown Umathsubshiftdrop Umathsubsupshiftdown contained
syn keyword texLuatex Umathsubsupvgap Umathsubtopmax Umathsupbottommin Umathsuperscriptvariant Umathsupshiftdistance contained
syn keyword texLuatex Umathsupshiftdrop Umathsupshiftup Umathsupsubbottommax Umathtopaccentvariant Umathunderbarkern contained
syn keyword texLuatex Umathunderbarrule Umathunderbarvgap Umathunderdelimiterbgap Umathunderdelimitervariant Umathunderdelimitervgap contained
syn keyword texLuatex Umathunderlinevariant Umathuseaxis Umathvextensiblevariant Umathvoid Umathxscale contained
syn keyword texLuatex Umathyscale Umiddle Unosubprescript Unosubscript Unosuperprescript contained
syn keyword texLuatex Unosuperscript Uoperator Uover Uoverdelimiter Uoverwithdelims contained
syn keyword 